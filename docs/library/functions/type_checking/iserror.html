<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="VB6Parse Library Reference - iserror - Type Checking">
    <title>iserror - Type Checking - VB6Parse Library Reference</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
    <link rel="stylesheet" href="../../../assets/css/docs-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="../../../assets/js/theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbnet.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header class="docs-header">
        <div class="container">
            <h1><a href="../../../index.html">VB6Parse</a> / <a href="../../../library/index.html">Library</a> / <a href="../../../library/functions/type_checking/index.html">Type Checking</a> / iserror</h1>
            <p class="tagline">VB6 Library Reference</p>
        </div>
    </header>

    <nav class="docs-nav">
        <div class="container">
            <a href="../../../index.html">Home</a>
            <a href="../../../library/index.html">Library Reference</a>
            <a href="../../../documentation.html">Documentation</a>
            <a href="https://docs.rs/vb6parse" target="_blank">API Docs</a>
            <a href="https://github.com/scriptandcompile/vb6parse" target="_blank">GitHub</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </div>
    </nav>

    <main class="container">
        
        <article class="library-item">
            <h1 id="iserror-function"><code>IsError</code> Function</h1>
<p>Returns a <code>Boolean</code> value indicating whether an expression is an error value.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="language-vbnet">IsError(expression)</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>expression</code> (Required): Variant expression to test</li>
</ul>
<h2 id="return-value">Return Value</h2>
<p>Returns a <code>Boolean</code>:
- <code>True</code> if the expression is an error value created by <code>CVErr</code>
- <code>False</code> if the expression is not an error value
- Only detects error values created with <code>CVErr</code> function
- Does not detect runtime errors or error objects
- Works with <code>Variant</code> variables containing error values
- Returns <code>False</code> for <code>Null</code>, <code>Empty</code>, or any non-error value</p>
<h2 id="remarks">Remarks</h2>
<p>The <code>IsError</code> function is used to determine whether a <code>Variant</code> expression contains an error value:</p>
<ul>
<li>Only detects <code>CVErr</code> error values (<code>Variant</code> subtype <code>vbError</code>)</li>
<li>Does not detect <code>Err</code> object or runtime errors</li>
<li>Error values are created using <code>CVErr</code> function</li>
<li>Useful for propagating errors through <code>Variant</code> returns</li>
<li>Common in functions that need to return error indicators</li>
<li>Error values are different from Null or Empty</li>
<li>Can be used to check function return values for errors</li>
<li>Error values preserve error numbers through call chains</li>
<li>Use <code>CVErr</code> to create error values, <code>IsError</code> to detect them</li>
<li><code>VarType(expr) = vbError</code> provides same functionality</li>
<li>Error values are uncommon in modern VB6 code</li>
<li>Most code uses <code>Err.Raise</code> for error handling instead</li>
</ul>
<h2 id="typical-uses">Typical Uses</h2>
<ol>
<li><strong>Error Propagation</strong>: Check if function returned an error value</li>
<li><strong>Error Value Detection</strong>: Identify <code>CVErr</code> values in <code>Variant</code> data</li>
<li><strong>Function Return Checking</strong>: Validate function results</li>
<li><strong>Array Processing</strong>: Detect errors in array elements</li>
<li><strong>Data Validation</strong>: Distinguish errors from valid data</li>
<li><strong>Legacy Code</strong>: Work with older code using <code>CVErr</code> pattern</li>
<li><strong>Error Chains</strong>: Propagate errors through multiple function calls</li>
<li><strong>Conditional Logic</strong>: Branch based on error presence</li>
</ol>
<h2 id="basic-usage-examples">Basic Usage Examples</h2>
<pre><code class="language-vbnet">&#x27; Example 1: Create and detect error values
Dim result As Variant

result = CVErr(5)  &#x27; Create error value with error number 5

If IsError(result) Then
Debug.Print &quot;Result is an error&quot;  &#x27; This prints
Debug.Print &quot;Error number: &quot; &amp; CLng(result)  &#x27; Prints: 5
End If

&#x27; Example 2: Distinguish error from other values
Dim testVar As Variant

testVar = CVErr(13)
Debug.Print IsError(testVar)        &#x27; True - error value
testVar = 13
Debug.Print IsError(testVar)        &#x27; False - regular number
testVar = Null
Debug.Print IsError(testVar)        &#x27; False - Null is not error
testVar = Empty
Debug.Print IsError(testVar)        &#x27; False - Empty is not error

&#x27; Example 3: Function returning error or value
Function SafeDivide(numerator As Double, denominator As Double) As Variant
If denominator = 0 Then
SafeDivide = CVErr(11)  &#x27; Division by zero error
Else
SafeDivide = numerator / denominator
End If
End Function

&#x27; Usage
Dim result As Variant
result = SafeDivide(10, 2)

If IsError(result) Then
MsgBox &quot;Error in calculation: &quot; &amp; CLng(result)
Else
MsgBox &quot;Result: &quot; &amp; result  &#x27; Prints: 5
End If

&#x27; Example 4: Process array with error checking
Function ProcessValues(values() As Variant) As Variant
Dim i As Integer
Dim total As Double

total = 0
For i = LBound(values) To UBound(values)
If IsError(values(i)) Then
ProcessValues = CVErr(CLng(values(i)))  &#x27; Propagate error
Exit Function
End If
total = total + values(i)
Next i

ProcessValues = total
End Function</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<pre><code class="language-vbnet">&#x27; Pattern 1: Safe function call with error checking
Function SafeGetValue(source As Variant, key As String) As Variant
On Error Resume Next
SafeGetValue = source(key)

If Err.Number &lt;&gt; 0 Then
SafeGetValue = CVErr(Err.Number)
End If
On Error GoTo 0
End Function

&#x27; Usage
Dim value As Variant
value = SafeGetValue(myDict, &quot;key&quot;)
If IsError(value) Then
MsgBox &quot;Error: &quot; &amp; CLng(value)
End If

&#x27; Pattern 2: Coalesce - return first non-error value
Function CoalesceValues(ParamArray values() As Variant) As Variant
Dim i As Long

For i = LBound(values) To UBound(values)
If Not IsError(values(i)) And Not IsNull(values(i)) And Not IsEmpty(values(i)) Then
CoalesceValues = values(i)
Exit Function
End If
Next i

CoalesceValues = CVErr(xlErrNA)  &#x27; All values were invalid
End Function

&#x27; Pattern 3: Get error number from error value
Function GetErrorNumber(errorValue As Variant) As Long
If IsError(errorValue) Then
GetErrorNumber = CLng(errorValue)
Else
GetErrorNumber = 0  &#x27; No error
End If
End Function

&#x27; Pattern 4: Chain operations with error propagation
Function CalculateResult(a As Variant, b As Variant) As Variant
If IsError(a) Then
CalculateResult = a  &#x27; Propagate first error
Exit Function
End If

If IsError(b) Then
CalculateResult = b  &#x27; Propagate second error
Exit Function
End If

&#x27; Perform calculation
CalculateResult = a + b
End Function

&#x27; Pattern 5: Validate all values before processing
Function AllValid(ParamArray values() As Variant) As Boolean
Dim i As Long

For i = LBound(values) To UBound(values)
If IsError(values(i)) Or IsNull(values(i)) Then
AllValid = False
Exit Function
End If
Next i

AllValid = True
End Function

&#x27; Pattern 6: Convert error to message
Function ErrorToMessage(value As Variant) As String
If IsError(value) Then
Select Case CLng(value)
Case 5
ErrorToMessage = &quot;Invalid procedure call&quot;
Case 7
ErrorToMessage = &quot;Out of memory&quot;
Case 9
ErrorToMessage = &quot;Subscript out of range&quot;
Case 11
ErrorToMessage = &quot;Division by zero&quot;
Case 13
ErrorToMessage = &quot;Type mismatch&quot;
Case Else
ErrorToMessage = &quot;Error &quot; &amp; CLng(value)
End Select
Else
ErrorToMessage = &quot;No error&quot;
End If
End Function

&#x27; Pattern 7: Default value for errors
Function ValueOrDefault(value As Variant, defaultValue As Variant) As Variant
If IsError(value) Or IsNull(value) Or IsEmpty(value) Then
ValueOrDefault = defaultValue
Else
ValueOrDefault = value
End If
End Function

&#x27; Pattern 8: Find first error in array
Function FindFirstError(arr As Variant) As Variant
Dim i As Long

If Not IsArray(arr) Then
FindFirstError = CVErr(13)  &#x27; Type mismatch
Exit Function
End If

For i = LBound(arr) To UBound(arr)
If IsError(arr(i)) Then
FindFirstError = arr(i)
Exit Function
End If
Next i

FindFirstError = Null  &#x27; No errors found
End Function

&#x27; Pattern 9: Count errors in array
Function CountErrors(arr As Variant) As Long
Dim i As Long
Dim count As Long

If Not IsArray(arr) Then
CountErrors = 0
Exit Function
End If

count = 0
For i = LBound(arr) To UBound(arr)
If IsError(arr(i)) Then
count = count + 1
End If
Next i

CountErrors = count
End Function

&#x27; Pattern 10: Safe numeric conversion
Function SafeCDbl(value As Variant) As Variant
On Error Resume Next
Dim result As Double

result = CDbl(value)

If Err.Number &lt;&gt; 0 Then
SafeCDbl = CVErr(Err.Number)
Else
SafeCDbl = result
End If
On Error GoTo 0
End Function</code></pre>
<h2 id="advanced-usage-examples">Advanced Usage Examples</h2>
<pre><code class="language-vbnet">&#x27; Example 1: Error-aware calculator class
Public Class SafeCalculator
Public Function Add(a As Variant, b As Variant) As Variant
If IsError(a) Then
Add = a
Exit Function
End If
If IsError(b) Then
Add = b
Exit Function
End If

On Error Resume Next
Add = a + b
If Err.Number &lt;&gt; 0 Then
Add = CVErr(Err.Number)
End If
On Error GoTo 0
End Function

Public Function Divide(numerator As Variant, denominator As Variant) As Variant
If IsError(numerator) Then
Divide = numerator
Exit Function
End If
If IsError(denominator) Then
Divide = denominator
Exit Function
End If

If denominator = 0 Then
Divide = CVErr(11)  &#x27; Division by zero
Exit Function
End If

Divide = numerator / denominator
End Function

Public Function GetErrorMessage(errorValue As Variant) As String
If Not IsError(errorValue) Then
GetErrorMessage = &quot;No error&quot;
Exit Function
End If

GetErrorMessage = &quot;Error &quot; &amp; CLng(errorValue) &amp; &quot;: &quot; &amp; _
Error$(CLng(errorValue))
End Function
End Class

&#x27; Example 2: Variant array processor with error handling
Public Class VariantArrayProcessor
Public Function Map(arr As Variant, callback As String) As Variant
&#x27; Apply callback function to each element, propagate errors
Dim result() As Variant
Dim i As Long

If Not IsArray(arr) Then
Map = CVErr(13)  &#x27; Type mismatch
Exit Function
End If

ReDim result(LBound(arr) To UBound(arr))

For i = LBound(arr) To UBound(arr)
If IsError(arr(i)) Then
result(i) = arr(i)  &#x27; Preserve error
Else
On Error Resume Next
result(i) = Application.Run(callback, arr(i))
If Err.Number &lt;&gt; 0 Then
result(i) = CVErr(Err.Number)
End If
On Error GoTo 0
End If
Next i

Map = result
End Function

Public Function Filter(arr As Variant) As Variant
&#x27; Remove error values from array
Dim result() As Variant
Dim i As Long, count As Long

If Not IsArray(arr) Then
Filter = Array()
Exit Function
End If

ReDim result(LBound(arr) To UBound(arr))
count = LBound(arr) - 1

For i = LBound(arr) To UBound(arr)
If Not IsError(arr(i)) Then
count = count + 1
result(count) = arr(i)
End If
Next i

If count &gt;= LBound(result) Then
ReDim Preserve result(LBound(result) To count)
Filter = result
Else
Filter = Array()
End If
End Function
End Class

&#x27; Example 3: Data validator with detailed error reporting
Public Class DataValidator
Private m_errors As Collection

Private Sub Class_Initialize()
Set m_errors = New Collection
End Sub

Public Function ValidateRecord(record As Variant) As Boolean
Dim i As Long
Dim fieldName As String

m_errors.Clear

If Not IsArray(record) Then
ValidateRecord = False
Exit Function
End If

For i = LBound(record) To UBound(record)
If IsError(record(i)) Then
m_errors.Add &quot;Field &quot; &amp; i &amp; &quot;: Error &quot; &amp; CLng(record(i))
ElseIf IsNull(record(i)) Then
m_errors.Add &quot;Field &quot; &amp; i &amp; &quot;: Null value&quot;
ElseIf IsEmpty(record(i)) Then
m_errors.Add &quot;Field &quot; &amp; i &amp; &quot;: Empty value&quot;
End If
Next i

ValidateRecord = (m_errors.Count = 0)
End Function

Public Function GetErrors() As Collection
Set GetErrors = m_errors
End Function

Public Function GetErrorSummary() As String
Dim msg As String
Dim i As Long

If m_errors.Count = 0 Then
GetErrorSummary = &quot;No errors&quot;
Exit Function
End If

msg = &quot;Found &quot; &amp; m_errors.Count &amp; &quot; error(s):&quot; &amp; vbCrLf
For i = 1 To m_errors.Count
msg = msg &amp; &quot;- &quot; &amp; m_errors(i) &amp; vbCrLf
Next i

GetErrorSummary = msg
End Function
End Class

&#x27; Example 4: Function composition with error handling
Function Compose(value As Variant, ParamArray functions() As Variant) As Variant
&#x27; Apply functions in sequence, stop on first error
Dim i As Long
Dim result As Variant

result = value

For i = LBound(functions) To UBound(functions)
If IsError(result) Then
Compose = result  &#x27; Propagate error
Exit Function
End If

On Error Resume Next
result = Application.Run(functions(i), result)
If Err.Number &lt;&gt; 0 Then
Compose = CVErr(Err.Number)
Exit Function
End If
On Error GoTo 0
Next i

Compose = result
End Function

&#x27; Usage:
&#x27; result = Compose(10, &quot;DoubleValue&quot;, &quot;AddTen&quot;, &quot;FormatResult&quot;)
&#x27; If IsError(result) Then MsgBox &quot;Error in processing&quot;</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>The <code>IsError</code> function itself does not raise errors:</p>
<pre><code class="language-vbnet">&#x27; IsError is safe to call on any value
Debug.Print IsError(123)           &#x27; False
Debug.Print IsError(&quot;text&quot;)        &#x27; False
Debug.Print IsError(CVErr(5))      &#x27; True
Debug.Print IsError(Null)          &#x27; False
Debug.Print IsError(Empty)         &#x27; False

&#x27; Common pattern: check and extract error number
If IsError(value) Then
Dim errNum As Long
errNum = CLng(value)  &#x27; Extract error number
MsgBox Error$(errNum) &#x27; Get error description
End If</code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li><strong>Fast Operation</strong>: <code>IsError</code> is a very fast type check</li>
<li><strong>Overhead</strong>: <code>CVErr</code>/<code>IsError</code> pattern has more overhead than <code>Err.Raise</code></li>
<li><strong>Modern Alternative</strong>: Most code uses structured error handling instead</li>
<li><strong>Legacy Code</strong>: Primarily seen in older VB6 and Excel VBA code</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Prefer <code>Err.Raise</code></strong>: Use structured error handling for most scenarios</li>
<li><strong>Check Returns</strong>: Always check <code>IsError</code> for functions returning <code>Variant</code></li>
<li><strong>Propagate Errors</strong>: Pass error values through call chains when appropriate</li>
<li><strong>Document Behavior</strong>: Clearly document when functions return error values</li>
<li><strong>Extract Numbers</strong>: Use <code>CLng(errorValue)</code> to get error number from error value</li>
<li><strong>Combine Checks</strong>: Check <code>IsError</code>, <code>IsNull</code>, and <code>IsEmpty</code> for complete validation</li>
<li><strong>Error Messages</strong>: Convert error numbers to messages for user display</li>
<li><strong>Avoid Overuse</strong>: <code>CVErr</code> pattern less common in modern VB6 code</li>
</ol>
<h2 id="comparison-with-related-functions">Comparison with Related Functions</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Purpose</th>
<th>Returns</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IsError</code></td>
<td>Check if <code>CVErr</code> value</td>
<td><code>Boolean</code></td>
<td>Detect error values</td>
</tr>
<tr>
<td><code>CVErr</code></td>
<td>Create error value</td>
<td><code>Variant</code> (Error)</td>
<td>Return error indicator</td>
</tr>
<tr>
<td><code>IsNull</code></td>
<td>Check if Null</td>
<td><code>Boolean</code></td>
<td>Detect Null values</td>
</tr>
<tr>
<td><code>IsEmpty</code></td>
<td>Check if uninitialized</td>
<td><code>Boolean</code></td>
<td>Detect Empty Variants</td>
</tr>
<tr>
<td><code>VarType</code></td>
<td>Get variant type</td>
<td><code>Integer</code></td>
<td>Detailed type information</td>
</tr>
<tr>
<td><code>Err.Raise</code></td>
<td>Raise runtime error</td>
<td>N/A</td>
<td>Structured error handling</td>
</tr>
<tr>
<td><code>Error$</code></td>
<td>Get error description</td>
<td><code>String</code></td>
<td>Error message from number</td>
</tr>
</tbody>
</table>
<h2 id="cverr-vs-errraise"><code>CVErr</code> vs <code>Err.Raise</code></h2>
<pre><code class="language-vbnet">&#x27; CVErr pattern (older style)
Function OldStyleDivide(a As Double, b As Double) As Variant
If b = 0 Then
OldStyleDivide = CVErr(11)  &#x27; Return error value
Else
OldStyleDivide = a / b
End If
End Function

If IsError(result) Then
MsgBox &quot;Error: &quot; &amp; CLng(result)
End If

&#x27; Err.Raise pattern (modern style)
Function ModernDivide(a As Double, b As Double) As Double
If b = 0 Then
Err.Raise 11, , &quot;Division by zero&quot;  &#x27; Raise error
Else
ModernDivide = a / b
End If
End Function

On Error Resume Next
result = ModernDivide(10, 0)
If Err.Number &lt;&gt; 0 Then
MsgBox &quot;Error: &quot; &amp; Err.Description
End If</code></pre>
<h2 id="platform-and-version-notes">Platform and Version Notes</h2>
<ul>
<li>Available in all VB6 versions</li>
<li>Part of VBA core functions</li>
<li>Returns <code>Boolean</code> type</li>
<li>Only detects <code>CVErr</code> error values (Variant subtype vbError)</li>
<li>Does not detect <code>Err</code> object or runtime errors</li>
<li>More common in Excel VBA than desktop VB6</li>
<li>Excel has predefined errors: <code>xlErrDiv0</code>, <code>xlErrNA</code>, <code>xlErrName</code>, <code>xlErrNull</code>, <code>xlErrNum</code>, <code>xlErrRef</code>, <code>xlErrValue</code></li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Only detects <code>CVErr</code> error values, not runtime errors</li>
<li>Does not provide error description (use <code>Error$</code> function)</li>
<li>Cannot distinguish different error types beyond number</li>
<li>Less flexible than structured error handling (Try/Catch equivalent)</li>
<li>Error values can be confusing when mixed with normal values</li>
<li>Not widely used in modern VB6 applications</li>
<li>Requires <code>Variant</code> return types (cannot use with typed returns)</li>
</ul>
<h2 id="related-functions">Related Functions</h2>
<ul>
<li><code>CVErr</code>: Create error value from error number</li>
<li><code>Error$</code>: Get error description from error number</li>
<li><code>IsNull</code>: Check if <code>Variant</code> is <code>Null</code></li>
<li><code>IsEmpty</code>: Check if <code>Variant</code> is <code>Empty</code></li>
<li><code>VarType</code>: Get detailed <code>Variant</code> type information</li>
<li><code>Err.Raise</code>: Raise runtime error (preferred modern approach)</li>
</ul>
        </article>
        
        <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
            <p>
                <a href="index.html">‚Üê Back to Type Checking</a> |
                <a href="../index.html">View all functions</a>
            </p>
        </div>

    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024-2026 VB6Parse Contributors. Licensed under the MIT License.</p>
        </div>
    </footer>
</body>
</html>
