<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="VB6Parse Library Reference - mid - String">
    <title>mid - String - VB6Parse Library Reference</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
    <link rel="stylesheet" href="../../../assets/css/docs-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="../../../assets/js/theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbnet.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header class="docs-header">
        <div class="container">
            <h1><a href="../../../index.html">VB6Parse</a> / <a href="../../../library/index.html">Library</a> / <a href="../../../library/functions/string/index.html">String</a> / mid</h1>
            <p class="tagline">VB6 Library Reference</p>
        </div>
    </header>

    <nav class="docs-nav">
        <div class="container">
            <a href="../../../index.html">Home</a>
            <a href="../../../library/index.html">Library Reference</a>
            <a href="../../../documentation.html">Documentation</a>
            <a href="https://docs.rs/vb6parse" target="_blank">API Docs</a>
            <a href="https://github.com/scriptandcompile/vb6parse" target="_blank">GitHub</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </div>
    </nav>

    <main class="container">
        
        <article class="library-item">
            <h1 id="mid-function">Mid Function</h1>
<p>Returns a Variant (String) containing a specified number of characters from a string.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="language-vbnet">Mid(string, start, [length])</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>string</code> (Required): String expression from which characters are returned</li>
<li>Can be any valid string expression</li>
<li>If Null, returns Null</li>
<li>
<p>If empty string, returns empty string</p>
</li>
<li>
<p><code>start</code> (Required): Long. Character position in string where the desired part begins</p>
</li>
<li>Uses 1-based indexing (first character is position 1)</li>
<li>If start &gt; Len(string), returns empty string</li>
<li>
<p>If start &lt; 1, error 5 (Invalid procedure call or argument)</p>
</li>
<li>
<p><code>length</code> (Optional): Long. Number of characters to return</p>
</li>
<li>If omitted or &gt; characters available, returns all characters from start to end</li>
<li>If length &lt; 0, error 5 (Invalid procedure call or argument)</li>
<li>If length = 0, returns empty string</li>
</ul>
<h2 id="return-value">Return Value</h2>
<p>Returns a Variant (String):
- Substring of specified length starting at start position
- Uses 1-based indexing (first character is 1, not 0)
- Returns empty string if start &gt; string length
- Returns remaining characters if length extends past end of string
- Returns Null if input string is Null
- Returns empty string if input string is empty
- Returns empty string if length = 0</p>
<h2 id="remarks">Remarks</h2>
<p>The Mid function extracts a substring:</p>
<ul>
<li><strong>1-based indexing</strong>: First character is at position 1 (not 0 like in many languages)</li>
<li><strong>Optional length</strong>: If omitted, returns from start to end of string</li>
<li><strong>Bounds handling</strong>: If start or length exceed string bounds, adjusts gracefully</li>
<li><strong>No error on overflow</strong>: Returns available characters without error</li>
<li><strong>Null propagation</strong>: Returns Null if input is Null</li>
<li><strong>Common use</strong>: Extract portions of strings, parse data, substring operations</li>
<li><strong>Related statement</strong>: Mid statement assigns to substring (Mid(s, 1, 3) = "abc")</li>
<li><strong>Similar to</strong>: Left (from start), Right (from end), <code>InStr</code> (find position)</li>
<li><strong>Performance</strong>: Fast operation, optimized in VB6</li>
<li><strong>String immutability</strong>: Returns new string, does not modify original</li>
<li><strong>Unicode support</strong>: Works with Unicode strings in VB6</li>
<li><strong>Type conversion</strong>: Automatically converts numeric strings</li>
<li><strong>Available in</strong>: All VB versions, VBA, <code>VBScript</code></li>
</ul>
<h2 id="typical-uses">Typical Uses</h2>
<ol>
<li><strong>Extract Substring</strong></li>
</ol>
<pre><code class="language-vbnet">middle = Mid(&quot;Hello World&quot;, 7, 5)  &#x27; Returns &quot;World&quot;</code></pre>
<ol>
<li><strong>Parse Fixed-Width Data</strong></li>
</ol>
<pre><code class="language-vbnet">customerID = Mid(record, 1, 10)
customerName = Mid(record, 11, 30)</code></pre>
<ol>
<li><strong>Extract from Position to End</strong></li>
</ol>
<pre><code class="language-vbnet">remainder = Mid(text, 5)  &#x27; From position 5 to end</code></pre>
<ol>
<li><strong>Parse Delimited Data</strong></li>
</ol>
<pre><code class="language-vbnet">pos = InStr(data, &quot;,&quot;)
firstField = Mid(data, 1, pos - 1)</code></pre>
<ol>
<li><strong>Skip Characters</strong></li>
</ol>
<pre><code class="language-vbnet">withoutPrefix = Mid(text, 4)  &#x27; Skip first 3 characters</code></pre>
<ol>
<li><strong>Extract Single Character</strong></li>
</ol>
<pre><code class="language-vbnet">char = Mid(text, i, 1)  &#x27; Get character at position i</code></pre>
<ol>
<li><strong>Data Validation</strong></li>
</ol>
<pre><code class="language-vbnet">areaCode = Mid(phoneNumber, 2, 3)  &#x27; Extract area code</code></pre>
<ol>
<li><strong>String Manipulation</strong></li>
</ol>
<pre><code class="language-vbnet">modified = Left(s, 5) &amp; &quot;***&quot; &amp; Mid(s, 9)  &#x27; Mask middle</code></pre>
<h2 id="basic-examples">Basic Examples</h2>
<h3 id="example-1-basic-usage">Example 1: Basic Usage</h3>
<pre><code class="language-vbnet">Dim result As String
Dim text As String

text = &quot;Hello World&quot;

&#x27; Extract with length
result = Mid(text, 1, 5)   &#x27; Returns &quot;Hello&quot;
result = Mid(text, 7, 5)   &#x27; Returns &quot;World&quot;
result = Mid(text, 3, 3)   &#x27; Returns &quot;llo&quot;

&#x27; Extract to end (no length parameter)
result = Mid(text, 7)      &#x27; Returns &quot;World&quot;
result = Mid(text, 1)      &#x27; Returns &quot;Hello World&quot;

&#x27; Edge cases
result = Mid(text, 20)     &#x27; Returns &quot;&quot; (start past end)
result = Mid(text, 7, 100) &#x27; Returns &quot;World&quot; (length past end)
result = Mid(text, 5, 0)   &#x27; Returns &quot;&quot; (zero length)</code></pre>
<h3 id="example-2-parse-fixed-width-record">Example 2: Parse Fixed-Width Record</h3>
<pre><code class="language-vbnet">Sub ParseFixedWidthRecord()
Dim record As String
Dim customerID As String
Dim customerName As String
Dim city As String
Dim state As String
Dim zipCode As String

&#x27; Example: &quot;CUST001   John Smith            New York    NY12345&quot;
record = &quot;CUST001   John Smith            New York    NY12345&quot;

&#x27; Parse fixed-width fields
customerID = RTrim(Mid(record, 1, 10))     &#x27; Positions 1-10
customerName = RTrim(Mid(record, 11, 22))  &#x27; Positions 11-32
city = RTrim(Mid(record, 33, 12))          &#x27; Positions 33-44
state = Mid(record, 45, 2)                  &#x27; Positions 45-46
zipCode = Mid(record, 47, 5)                &#x27; Positions 47-51

Debug.Print &quot;ID: &quot; &amp; customerID
Debug.Print &quot;Name: &quot; &amp; customerName
Debug.Print &quot;City: &quot; &amp; city
Debug.Print &quot;State: &quot; &amp; state
Debug.Print &quot;Zip: &quot; &amp; zipCode
End Sub</code></pre>
<h3 id="example-3-extract-file-extension">Example 3: Extract File Extension</h3>
<pre><code class="language-vbnet">Function GetFileExtension(ByVal filename As String) As String
Dim dotPos As Long

&#x27; Find last dot
dotPos = InStrRev(filename, &quot;.&quot;)

If dotPos &gt; 0 Then
&#x27; Extract extension (without dot)
GetFileExtension = Mid(filename, dotPos + 1)
Else
GetFileExtension = &quot;&quot;
End If
End Function

&#x27; Usage:
&#x27; ext = GetFileExtension(&quot;document.txt&quot;)      &#x27; Returns &quot;txt&quot;
&#x27; ext = GetFileExtension(&quot;photo.jpg&quot;)         &#x27; Returns &quot;jpg&quot;
&#x27; ext = GetFileExtension(&quot;archive.tar.gz&quot;)    &#x27; Returns &quot;gz&quot;
&#x27; ext = GetFileExtension(&quot;README&quot;)            &#x27; Returns &quot;&quot;</code></pre>
<h3 id="example-4-parse-delimited-string">Example 4: Parse Delimited String</h3>
<pre><code class="language-vbnet">Sub ParseCSVLine(ByVal line As String)
Dim pos1 As Long, pos2 As Long
Dim field1 As String, field2 As String, field3 As String

&#x27; Parse: &quot;Smith,John,123 Main St&quot;

&#x27; Find first comma
pos1 = InStr(line, &quot;,&quot;)
If pos1 &gt; 0 Then
field1 = Mid(line, 1, pos1 - 1)

&#x27; Find second comma
pos2 = InStr(pos1 + 1, line, &quot;,&quot;)
If pos2 &gt; 0 Then
field2 = Mid(line, pos1 + 1, pos2 - pos1 - 1)
field3 = Mid(line, pos2 + 1)  &#x27; Rest of string
Else
field2 = Mid(line, pos1 + 1)  &#x27; No third field
field3 = &quot;&quot;
End If
Else
field1 = line
field2 = &quot;&quot;
field3 = &quot;&quot;
End If

Debug.Print &quot;Last Name: &quot; &amp; field1
Debug.Print &quot;First Name: &quot; &amp; field2
Debug.Print &quot;Address: &quot; &amp; field3
End Sub</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="pattern-1-safemid-handle-null">Pattern 1: <code>SafeMid</code> (handle Null)</h3>
<pre><code class="language-vbnet">Function SafeMid(ByVal text As Variant, _
ByVal start As Long, _
Optional ByVal length As Long = -1) As String
If IsNull(text) Then
SafeMid = &quot;&quot;
ElseIf length = -1 Then
SafeMid = Mid(text, start)
Else
SafeMid = Mid(text, start, length)
End If
End Function</code></pre>
<h3 id="pattern-2-getchar-extract-single-character">Pattern 2: <code>GetChar</code> (extract single character)</h3>
<pre><code class="language-vbnet">Function GetChar(ByVal text As String, ByVal position As Long) As String
If position &gt;= 1 And position &lt;= Len(text) Then
GetChar = Mid(text, position, 1)
Else
GetChar = &quot;&quot;
End If
End Function</code></pre>
<h3 id="pattern-3-skipchars-remove-prefix">Pattern 3: <code>SkipChars</code> (remove prefix)</h3>
<pre><code class="language-vbnet">Function SkipChars(ByVal text As String, ByVal count As Long) As String
If count &gt;= Len(text) Then
SkipChars = &quot;&quot;
ElseIf count &lt;= 0 Then
SkipChars = text
Else
SkipChars = Mid(text, count + 1)
End If
End Function</code></pre>
<h3 id="pattern-4-extractbetween">Pattern 4: <code>ExtractBetween</code></h3>
<pre><code class="language-vbnet">Function ExtractBetween(ByVal text As String, _
ByVal startPos As Long, _
ByVal endPos As Long) As String
If endPos &gt;= startPos And startPos &gt;= 1 Then
ExtractBetween = Mid(text, startPos, endPos - startPos + 1)
Else
ExtractBetween = &quot;&quot;
End If
End Function</code></pre>
<h3 id="pattern-5-maskmiddle-hide-sensitive-data">Pattern 5: <code>MaskMiddle</code> (hide sensitive data)</h3>
<pre><code class="language-vbnet">Function MaskMiddle(ByVal text As String, _
ByVal visibleStart As Long, _
ByVal visibleEnd As Long) As String
Dim textLen As Long
textLen = Len(text)

If textLen &lt;= visibleStart + visibleEnd Then
MaskMiddle = text
Else
MaskMiddle = Left(text, visibleStart) &amp; _
String(textLen - visibleStart - visibleEnd, &quot;*&quot;) &amp; _
Right(text, visibleEnd)
End If
End Function</code></pre>
<h3 id="pattern-6-parsefixedfield">Pattern 6: <code>ParseFixedField</code></h3>
<pre><code class="language-vbnet">Function ParseFixedField(ByVal record As String, _
ByVal startPos As Long, _
ByVal fieldWidth As Long) As String
ParseFixedField = RTrim(Mid(record, startPos, fieldWidth))
End Function</code></pre>
<h3 id="pattern-7-getsubstringafter">Pattern 7: <code>GetSubstringAfter</code></h3>
<pre><code class="language-vbnet">Function GetSubstringAfter(ByVal text As String, _
ByVal delimiter As String) As String
Dim pos As Long
pos = InStr(text, delimiter)

If pos &gt; 0 Then
GetSubstringAfter = Mid(text, pos + Len(delimiter))
Else
GetSubstringAfter = &quot;&quot;
End If
End Function</code></pre>
<h3 id="pattern-8-getsubstringbefore">Pattern 8: <code>GetSubstringBefore</code></h3>
<pre><code class="language-vbnet">Function GetSubstringBefore(ByVal text As String, _
ByVal delimiter As String) As String
Dim pos As Long
pos = InStr(text, delimiter)

If pos &gt; 0 Then
GetSubstringBefore = Mid(text, 1, pos - 1)
Else
GetSubstringBefore = text
End If
End Function</code></pre>
<h3 id="pattern-9-replacemiddle">Pattern 9: <code>ReplaceMiddle</code></h3>
<pre><code class="language-vbnet">Function ReplaceMiddle(ByVal text As String, _
ByVal start As Long, _
ByVal length As Long, _
ByVal replacement As String) As String
ReplaceMiddle = Left(text, start - 1) &amp; _
replacement &amp; _
Mid(text, start + length)
End Function</code></pre>
<h3 id="pattern-10-extractword">Pattern 10: <code>ExtractWord</code></h3>
<pre><code class="language-vbnet">Function ExtractWord(ByVal text As String, ByVal wordNum As Long) As String
Dim words() As String
words = Split(Trim(text))

If wordNum &gt;= 1 And wordNum &lt;= UBound(words) + 1 Then
ExtractWord = words(wordNum - 1)
Else
ExtractWord = &quot;&quot;
End If
End Function</code></pre>
<h2 id="advanced-examples">Advanced Examples</h2>
<h3 id="example-1-fixed-width-file-parser">Example 1: Fixed-Width File Parser</h3>
<pre><code class="language-vbnet">&#x27; Class: FixedWidthParser
Private Type FieldDefinition
Name As String
StartPos As Long
Length As Long
TrimSpaces As Boolean
End Type

Private m_fields() As FieldDefinition
Private m_fieldCount As Long

Public Sub AddField(ByVal name As String, _
ByVal startPos As Long, _
ByVal length As Long, _
Optional ByVal trimSpaces As Boolean = True)
m_fieldCount = m_fieldCount + 1
ReDim Preserve m_fields(1 To m_fieldCount)

With m_fields(m_fieldCount)
.Name = name
.StartPos = startPos
.Length = length
.TrimSpaces = trimSpaces
End With
End Sub

Public Function ParseRecord(ByVal record As String) As Collection
Dim result As New Collection
Dim i As Long
Dim value As String

For i = 1 To m_fieldCount
With m_fields(i)
value = Mid(record, .StartPos, .Length)

If .TrimSpaces Then
value = Trim(value)
End If

result.Add value, .Name
End With
Next i

Set ParseRecord = result
End Function

Public Sub ParseFile(ByVal filename As String, _
ByVal outputCollection As Collection)
Dim fileNum As Integer
Dim line As String
Dim recordData As Collection

fileNum = FreeFile
Open filename For Input As #fileNum

Do While Not EOF(fileNum)
Line Input #fileNum, line
Set recordData = ParseRecord(line)
outputCollection.Add recordData
Loop

Close #fileNum
End Sub</code></pre>
<h3 id="example-2-string-tokenizer">Example 2: String Tokenizer</h3>
<pre><code class="language-vbnet">&#x27; Class: StringTokenizer
Private m_text As String
Private m_position As Long
Private m_length As Long

Public Sub Initialize(ByVal text As String)
m_text = text
m_position = 1
m_length = Len(text)
End Sub

Public Function HasMoreTokens() As Boolean
HasMoreTokens = (m_position &lt;= m_length)
End Function

Public Function NextToken(ByVal delimiter As String) As String
Dim delimPos As Long
Dim token As String

If m_position &gt; m_length Then
NextToken = &quot;&quot;
Exit Function
End If

&#x27; Find next delimiter
delimPos = InStr(m_position, m_text, delimiter)

If delimPos = 0 Then
&#x27; No more delimiters, return rest of string
token = Mid(m_text, m_position)
m_position = m_length + 1
Else
&#x27; Extract token
token = Mid(m_text, m_position, delimPos - m_position)
m_position = delimPos + Len(delimiter)
End If

NextToken = token
End Function

Public Function PeekToken(ByVal delimiter As String) As String
Dim savedPos As Long
savedPos = m_position
PeekToken = NextToken(delimiter)
m_position = savedPos
End Function

Public Sub Reset()
m_position = 1
End Sub

Public Property Get Position() As Long
Position = m_position
End Property

Public Property Let Position(ByVal newPos As Long)
If newPos &gt;= 1 And newPos &lt;= m_length + 1 Then
m_position = newPos
End If
End Property</code></pre>
<h3 id="example-3-string-masking-utility">Example 3: String Masking Utility</h3>
<pre><code class="language-vbnet">&#x27; Module: StringMasking

Public Function MaskCreditCard(ByVal cardNumber As String) As String
&#x27; Show last 4 digits: **** **** **** 1234
Dim cleaned As String
cleaned = Replace(cardNumber, &quot; &quot;, &quot;&quot;)
cleaned = Replace(cleaned, &quot;-&quot;, &quot;&quot;)

If Len(cleaned) &gt;= 4 Then
MaskCreditCard = String(Len(cleaned) - 4, &quot;*&quot;) &amp; Mid(cleaned, Len(cleaned) - 3)
Else
MaskCreditCard = String(Len(cleaned), &quot;*&quot;)
End If
End Function

Public Function MaskSSN(ByVal ssn As String) As String
&#x27; Show last 4 digits: ***-**-1234
Dim cleaned As String
cleaned = Replace(ssn, &quot;-&quot;, &quot;&quot;)

If Len(cleaned) = 9 Then
MaskSSN = &quot;***-**-&quot; &amp; Mid(cleaned, 6)
Else
MaskSSN = String(Len(ssn), &quot;*&quot;)
End If
End Function

Public Function MaskEmail(ByVal email As String) As String
&#x27; Show first 2 chars and domain: jo****@example.com
Dim atPos As Long
Dim localPart As String
Dim domainPart As String

atPos = InStr(email, &quot;@&quot;)

If atPos &gt; 2 Then
localPart = Mid(email, 1, 2) &amp; String(atPos - 3, &quot;*&quot;)
domainPart = Mid(email, atPos)
MaskEmail = localPart &amp; domainPart
Else
MaskEmail = String(Len(email), &quot;*&quot;)
End If
End Function

Public Function MaskPhone(ByVal phoneNumber As String) As String
&#x27; Show area code and last 2: (123) ***-**34
Dim cleaned As String
cleaned = Replace(phoneNumber, &quot;(&quot;, &quot;&quot;)
cleaned = Replace(cleaned, &quot;)&quot;, &quot;&quot;)
cleaned = Replace(cleaned, &quot; &quot;, &quot;&quot;)
cleaned = Replace(cleaned, &quot;-&quot;, &quot;&quot;)

If Len(cleaned) = 10 Then
MaskPhone = &quot;(&quot; &amp; Mid(cleaned, 1, 3) &amp; &quot;) ***-**&quot; &amp; Mid(cleaned, 9)
Else
MaskPhone = String(Len(phoneNumber), &quot;*&quot;)
End If
End Function</code></pre>
<h3 id="example-4-csv-parser-with-quoted-fields">Example 4: CSV Parser with Quoted Fields</h3>
<pre><code class="language-vbnet">&#x27; Module: CSVParser

Public Function ParseCSVLine(ByVal line As String) As Variant
Dim fields() As String
Dim fieldCount As Long
Dim position As Long
Dim length As Long
Dim inQuote As Boolean
Dim currentField As String
Dim ch As String

length = Len(line)
position = 1
fieldCount = 0
inQuote = False
currentField = &quot;&quot;

Do While position &lt;= length
ch = Mid(line, position, 1)

Select Case ch
Case &quot;&quot;&quot;&quot;  &#x27; Quote
If inQuote Then
&#x27; Check for escaped quote
If position &lt; length Then
If Mid(line, position + 1, 1) = &quot;&quot;&quot;&quot; Then
currentField = currentField &amp; &quot;&quot;&quot;&quot;
position = position + 1
Else
inQuote = False
End If
Else
inQuote = False
End If
Else
inQuote = True
End If

Case &quot;,&quot;
If inQuote Then
currentField = currentField &amp; ch
Else
&#x27; End of field
fieldCount = fieldCount + 1
ReDim Preserve fields(1 To fieldCount)
fields(fieldCount) = currentField
currentField = &quot;&quot;
End If

Case Else
currentField = currentField &amp; ch
End Select

position = position + 1
Loop

&#x27; Add last field
fieldCount = fieldCount + 1
ReDim Preserve fields(1 To fieldCount)
fields(fieldCount) = currentField

ParseCSVLine = fields
End Function

Public Function GetCSVField(ByVal line As String, _
ByVal fieldIndex As Long) As String
Dim fields As Variant
fields = ParseCSVLine(line)

If fieldIndex &gt;= LBound(fields) And fieldIndex &lt;= UBound(fields) Then
GetCSVField = fields(fieldIndex)
Else
GetCSVField = &quot;&quot;
End If
End Function</code></pre>
<h2 id="error-handling">Error Handling</h2>
<pre><code class="language-vbnet">&#x27; Error 5: Invalid procedure call or argument
&#x27; - start &lt; 1
&#x27; - length &lt; 0

&#x27; Safe extraction with error handling
Function SafeExtract(ByVal text As String, _
ByVal start As Long, _
ByVal length As Long) As String
On Error GoTo ErrorHandler

If IsNull(text) Then
SafeExtract = &quot;&quot;
ElseIf start &lt; 1 Or length &lt; 0 Then
SafeExtract = &quot;&quot;
ElseIf start &gt; Len(text) Then
SafeExtract = &quot;&quot;
Else
SafeExtract = Mid(text, start, length)
End If

Exit Function

ErrorHandler:
SafeExtract = &quot;&quot;
End Function

&#x27; Handle Null values
Function MidSafe(ByVal text As Variant, _
ByVal start As Long, _
Optional ByVal length As Variant = Empty) As String
If IsNull(text) Then
MidSafe = &quot;&quot;
ElseIf IsEmpty(length) Then
MidSafe = Mid(text, start)
Else
MidSafe = Mid(text, start, length)
End If
End Function</code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li><strong>Fast Operation</strong>: String extraction is highly optimized in VB6</li>
<li><strong>Creates New String</strong>: Does not modify original (immutable)</li>
<li><strong>Avoid in Tight Loops</strong>: Cache result if using multiple times</li>
<li><strong>Better than</strong>: Repeated Left/Right operations for complex parsing</li>
<li><strong>Consider Split</strong>: For delimited data, Split may be faster</li>
<li><strong>String Builder</strong>: For concatenating many Mid results, use <code>StringBuilder</code> pattern</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Remember 1-based indexing</strong> - First character is position 1, not 0</li>
<li><strong>Validate inputs</strong> - Check start and length before calling Mid</li>
<li><strong>Handle Null gracefully</strong> - Use <code>IsNull</code> check for Variant inputs</li>
<li><strong>Omit length when extracting to end</strong> - More readable: Mid(s, 5) vs Mid(s, 5, Len(s)-4)</li>
<li><strong>Combine with Trim</strong> - Clean whitespace from extracted fields</li>
<li><strong>Use with <code>InStr</code></strong> - Find position, then extract with Mid</li>
<li><strong>Cache Len results</strong> - If using Len(string) multiple times</li>
<li><strong>Document field positions</strong> - For fixed-width parsing, use constants</li>
<li><strong>Test edge cases</strong> - Empty strings, start past end, Null values</li>
<li><strong>Consider alternatives</strong> - Split for delimited data, Left/Right for ends</li>
</ol>
<h2 id="comparison-with-related-functions">Comparison with Related Functions</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Extracts From</th>
<th>Parameters</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mid</strong></td>
<td>Any position</td>
<td><code>(string, start, [length])</code></td>
<td>General substring extraction</td>
</tr>
<tr>
<td><strong>Left</strong></td>
<td>Beginning</td>
<td><code>(string, length)</code></td>
<td>Get first N characters</td>
</tr>
<tr>
<td><strong>Right</strong></td>
<td>End</td>
<td><code>(string, length)</code></td>
<td>Get last N characters</td>
</tr>
<tr>
<td><strong><code>InStr</code></strong></td>
<td>N/A (finds)</td>
<td><code>[start,] string1, string2</code></td>
<td>Find position of substring</td>
</tr>
</tbody>
</table>
<h2 id="mid-vs-left-vs-right">Mid vs Left vs Right</h2>
<pre><code class="language-vbnet">Dim text As String
text = &quot;Hello World&quot;

&#x27; Mid - extract from any position
Debug.Print Mid(text, 7, 5)    &#x27; &quot;World&quot; (position 7, length 5)
Debug.Print Mid(text, 3, 3)    &#x27; &quot;llo&quot; (position 3, length 3)
Debug.Print Mid(text, 7)       &#x27; &quot;World&quot; (from position 7 to end)

&#x27; Left - extract from beginning
Debug.Print Left(text, 5)      &#x27; &quot;Hello&quot; (first 5 characters)

&#x27; Right - extract from end
Debug.Print Right(text, 5)     &#x27; &quot;World&quot; (last 5 characters)

&#x27; Equivalent operations
Debug.Print Mid(text, 1, 5)    &#x27; &quot;Hello&quot; (same as Left(text, 5))
Debug.Print Mid(text, 7)       &#x27; &quot;World&quot; (same as Right(text, 5))</code></pre>
<h2 id="mid-function-vs-mid-statement">Mid Function vs Mid Statement</h2>
<pre><code class="language-vbnet">Dim text As String
text = &quot;Hello World&quot;

&#x27; Mid Function - returns substring (does not modify)
Dim result As String
result = Mid(text, 1, 5)       &#x27; result = &quot;Hello&quot;, text unchanged

&#x27; Mid Statement - modifies string in place
Mid(text, 1, 5) = &quot;Goodbye&quot;    &#x27; text = &quot;GoodbyWorld&quot; (replaces 5 chars)
Mid(text, 7, 5) = &quot;Earth&quot;      &#x27; text = &quot;Hello Earth&quot; (replaces 5 chars)

&#x27; Note: Mid statement exists but is less commonly used
&#x27; Mid function is much more common for extraction</code></pre>
<h2 id="1-based-vs-0-based-indexing">1-Based vs 0-Based Indexing</h2>
<pre><code class="language-vbnet">&#x27; VB6 Mid uses 1-based indexing
Dim text As String
text = &quot;ABCDE&quot;

Debug.Print Mid(text, 1, 1)    &#x27; &quot;A&quot; (first character is position 1)
Debug.Print Mid(text, 2, 1)    &#x27; &quot;B&quot; (second character is position 2)
Debug.Print Mid(text, 5, 1)    &#x27; &quot;E&quot; (fifth character is position 5)

&#x27; Compare to 0-based languages (JavaScript, C#, etc.)
&#x27; text[0]   // &quot;A&quot; (first character is index 0)
&#x27; text[1]   // &quot;B&quot; (second character is index 1)
&#x27; text[4]   // &quot;E&quot; (fifth character is index 4)

&#x27; When converting between languages:
&#x27; VB6: Mid(text, n, 1)
&#x27; C#:  text[n-1]</code></pre>
<h2 id="platform-notes">Platform Notes</h2>
<ul>
<li>Available in all VB6 versions</li>
<li>Part of VBA core library</li>
<li>Available in <code>VBScript</code></li>
<li>Works with ANSI and Unicode strings</li>
<li><strong>1-based indexing</strong> (first character is 1)</li>
<li>Returns new string (original unchanged)</li>
<li>Handles Null by returning Null</li>
<li>No error if start or length exceed bounds (adjusts gracefully)</li>
<li>Same behavior across all Windows versions</li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li><strong>1-based indexing</strong>: Not 0-based like most modern languages</li>
<li><strong>Creates new string</strong>: Cannot modify string in place (use Mid statement for that)</li>
<li><strong>No negative indices</strong>: Cannot count from end like Python</li>
<li><strong>No regex support</strong>: For pattern matching, use <code>RegExp</code> object</li>
<li><strong>Error on invalid start</strong>: start &lt; 1 causes error 5</li>
<li><strong>Error on negative length</strong>: length &lt; 0 causes error 5</li>
</ul>
<h2 id="related-functions">Related Functions</h2>
<ul>
<li><code>Left</code>: Returns leftmost characters from string</li>
<li><code>Right</code>: Returns rightmost characters from string</li>
<li><code>InStr</code>: Finds position of substring</li>
<li><code>InStrRev</code>: Finds position of substring from end</li>
<li><code>Len</code>: Returns string length</li>
<li><code>LTrim</code>/<code>RTrim</code>/<code>Trim</code>: Removes spaces</li>
<li><code>Split</code>: Splits string into array</li>
<li><code>Replace</code>: Replaces substring occurrences</li>
<li><code>Mid</code> statement: Replaces characters within string</li>
</ul>
        </article>
        
        <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
            <p>
                <a href="index.html">‚Üê Back to String</a> |
                <a href="../index.html">View all functions</a>
            </p>
        </div>

    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024-2026 VB6Parse Contributors. Licensed under the MIT License.</p>
        </div>
    </footer>
</body>
</html>
