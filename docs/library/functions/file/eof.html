<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="VB6Parse Library Reference - eof - File">
    <title>eof - File - VB6Parse Library Reference</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
    <link rel="stylesheet" href="../../../assets/css/docs-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="../../../assets/js/theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbnet.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header class="docs-header">
        <div class="container">
            <h1><a href="../../../index.html">VB6Parse</a> / <a href="../../../library/index.html">Library</a> / <a href="../../../library/functions/file/index.html">File</a> / eof</h1>
            <p class="tagline">VB6 Library Reference</p>
        </div>
    </header>

    <nav class="docs-nav">
        <div class="container">
            <a href="../../../index.html">Home</a>
            <a href="../../../library/index.html">Library Reference</a>
            <a href="../../../documentation.html">Documentation</a>
            <a href="https://docs.rs/vb6parse" target="_blank">API Docs</a>
            <a href="https://github.com/scriptandcompile/vb6parse" target="_blank">GitHub</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </div>
    </nav>

    <main class="container">
        
        <article class="library-item">
            <h1 id="eof-function">EOF Function</h1>
<p>Returns a Boolean value indicating whether the end of a file opened for Random or sequential
Input has been reached.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="language-vbnet">EOF(filenumber)</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li><strong>filenumber</strong>: Required. An Integer containing a valid file number.</li>
</ul>
<h2 id="return-value">Return Value</h2>
<p>Returns a Boolean value. Returns True when the end of a file opened for Random or Input
access has been reached; otherwise, returns False.</p>
<h2 id="remarks">Remarks</h2>
<p>The <code>EOF</code> function is used to detect when the end of a file has been reached during
sequential or random file reading operations. It's essential for controlling loops that
read through files.
<strong>Important Characteristics:</strong>
- Returns True when end of file is reached
- Returns False when more data is available
- Works with files opened for Input or Random access
- Does not work with files opened for Output or Append
- Does not work with binary mode files (use LOF instead)
- File must be open before calling EOF
- Error if file number is invalid or file is closed
- Position-dependent (affected by Get, Input, Line Input)
- Can be used to prevent "Input past end of file" error</p>
<h2 id="file-access-modes">File Access Modes</h2>
<ul>
<li><strong>Input</strong>: Sequential text file reading - EOF returns True after last character</li>
<li><strong>Random</strong>: Random access files - EOF returns True after last record</li>
<li><strong>Binary</strong>: Not supported (use LOF and Seek instead)</li>
<li><strong>Output/Append</strong>: Not applicable (write modes)</li>
</ul>
<h2 id="examples">Examples</h2>
<h3 id="basic-usage">Basic Usage</h3>
<pre><code class="language-vbnet">&#x27; Read text file line by line
Dim fileNum As Integer
Dim line As String
fileNum = FreeFile
Open &quot;C:\data.txt&quot; For Input As #fileNum
Do Until EOF(fileNum)
    Line Input #fileNum, line
    Debug.Print line
Loop
Close #fileNum</code></pre>
<h3 id="read-all-lines-into-array">Read All Lines into Array</h3>
<pre><code class="language-vbnet">Function ReadAllLines(filePath As String) As Variant
    Dim fileNum As Integer
    Dim lines() As String
    Dim line As String
    Dim count As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    count = 0
    ReDim lines(0 To 100)
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        lines(count) = line
        count = count + 1
        If count &gt; UBound(lines) Then
            ReDim Preserve lines(0 To UBound(lines) + 100)
        End If
    Loop
    Close #fileNum
    If count &gt; 0 Then
        ReDim Preserve lines(0 To count - 1)
        ReadAllLines = lines
    Else
        ReadAllLines = Array()
    End If
End Function</code></pre>
<h3 id="random-access-file">Random Access File</h3>
<pre><code class="language-vbnet">Type CustomerRecord
    ID As Long
    Name As String * 50
    Balance As Double
End Type
Sub ReadAllCustomers()
    Dim fileNum As Integer
    Dim customer As CustomerRecord
    fileNum = FreeFile
    Open &quot;customers.dat&quot; For Random As #fileNum Len = Len(customer)
    Do Until EOF(fileNum)
        Get #fileNum, , customer
        Debug.Print customer.ID, customer.Name, customer.Balance
    Loop
    Close #fileNum
End Sub</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="count-lines-in-file">Count Lines in File</h3>
<pre><code class="language-vbnet">Function CountLines(filePath As String) As Long
    Dim fileNum As Integer
    Dim line As String
    Dim count As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    count = 0
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        count = count + 1
    Loop
    Close #fileNum
    CountLines = count
End Function</code></pre>
<h3 id="search-file-for-text">Search File for Text</h3>
<pre><code class="language-vbnet">Function FindInFile(filePath As String, searchText As String) As Boolean
    Dim fileNum As Integer
    Dim line As String
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    FindInFile = False
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        If InStr(1, line, searchText, vbTextCompare) &gt; 0 Then
            FindInFile = True
            Exit Do
        End If
    Loop
    Close #fileNum
End Function</code></pre>
<h3 id="read-csv-file">Read CSV File</h3>
<pre><code class="language-vbnet">Function ReadCSV(filePath As String) As Variant
    Dim fileNum As Integer
    Dim line As String
    Dim rows() As Variant
    Dim rowCount As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    rowCount = 0
    ReDim rows(0 To 100)
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        rows(rowCount) = Split(line, &quot;,&quot;)
        rowCount = rowCount + 1
        If rowCount &gt; UBound(rows) Then
            ReDim Preserve rows(0 To UBound(rows) + 100)
        End If
    Loop
    Close #fileNum
    If rowCount &gt; 0 Then
        ReDim Preserve rows(0 To rowCount - 1)
        ReadCSV = rows
    Else
        ReadCSV = Array()
    End If
End Function</code></pre>
<h3 id="process-file-with-progress">Process File with Progress</h3>
<pre><code class="language-vbnet">Sub ProcessFileWithProgress(filePath As String)
    Dim fileNum As Integer
    Dim line As String
    Dim lineCount As Long
    Dim processedCount As Long
    &#x27; Count total lines first
    lineCount = CountLines(filePath)
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    processedCount = 0
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        ProcessLine line
        processedCount = processedCount + 1
        &#x27; Update progress
        If processedCount Mod 100 = 0 Then
            lblProgress.Caption = processedCount &amp; &quot; of &quot; &amp; lineCount
            DoEvents
        End If
    Loop
    Close #fileNum
End Sub</code></pre>
<h3 id="read-until-marker">Read Until Marker</h3>
<pre><code class="language-vbnet">Function ReadUntilMarker(fileNum As Integer, marker As String) As String
    Dim line As String
    Dim content As String
    content = &quot;&quot;
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        If line = marker Then
            Exit Do
        End If
        content = content &amp; line &amp; vbCrLf
    Loop
    ReadUntilMarker = content
End Function</code></pre>
<h3 id="skip-header-lines">Skip Header Lines</h3>
<pre><code class="language-vbnet">Sub ProcessDataFile(filePath As String, headerLines As Integer)
    Dim fileNum As Integer
    Dim line As String
    Dim i As Integer
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    &#x27; Skip header lines
    For i = 1 To headerLines
        If Not EOF(fileNum) Then
            Line Input #fileNum, line
        End If
    Next i
    &#x27; Process remaining data
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        ProcessDataLine line
    Loop
    Close #fileNum
End Sub</code></pre>
<h3 id="read-fixed-number-of-lines">Read Fixed Number of Lines</h3>
<pre><code class="language-vbnet">Function ReadLines(filePath As String, maxLines As Long) As Variant
    Dim fileNum As Integer
    Dim lines() As String
    Dim line As String
    Dim count As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    ReDim lines(0 To maxLines - 1)
    count = 0
    Do Until EOF(fileNum) Or count &gt;= maxLines
        Line Input #fileNum, line
        lines(count) = line
        count = count + 1
    Loop
    Close #fileNum
    If count &gt; 0 Then
        ReDim Preserve lines(0 To count - 1)
        ReadLines = lines
    Else
        ReadLines = Array()
    End If
End Function</code></pre>
<h3 id="merge-multiple-files">Merge Multiple Files</h3>
<pre><code class="language-vbnet">Sub MergeFiles(inputFiles As Variant, outputFile As String)
    Dim outNum As Integer
    Dim inNum As Integer
    Dim i As Integer
    Dim line As String
    outNum = FreeFile
    Open outputFile For Output As #outNum
    For i = LBound(inputFiles) To UBound(inputFiles)
        inNum = FreeFile
        Open inputFiles(i) For Input As #inNum
        Do Until EOF(inNum)
            Line Input #inNum, line
            Print #outNum, line
        Loop
        Close #inNum
    Next i
    Close #outNum
End Sub</code></pre>
<h3 id="filter-file-contents">Filter File Contents</h3>
<pre><code class="language-vbnet">Sub FilterFile(inputFile As String, outputFile As String, filterText As String)
    Dim inNum As Integer
    Dim outNum As Integer
    Dim line As String
    inNum = FreeFile
    Open inputFile For Input As #inNum
    outNum = FreeFile
    Open outputFile For Output As #outNum
    Do Until EOF(inNum)
        Line Input #inNum, line
        If InStr(1, line, filterText, vbTextCompare) &gt; 0 Then
            Print #outNum, line
        End If
    Loop
    Close #inNum
    Close #outNum
End Sub</code></pre>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="parse-configuration-file">Parse Configuration File</h3>
<pre><code class="language-vbnet">Function ParseConfigFile(filePath As String) As Collection
    Dim fileNum As Integer
    Dim line As String
    Dim config As New Collection
    Dim equalPos As Integer
    Dim key As String
    Dim value As String
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        line = Trim(line)
        &#x27; Skip empty lines and comments
        If Len(line) &gt; 0 And Left(line, 1) &lt;&gt; &quot;#&quot; Then
            equalPos = InStr(line, &quot;=&quot;)
            If equalPos &gt; 0 Then
                key = Trim(Left(line, equalPos - 1))
                value = Trim(Mid(line, equalPos + 1))
                On Error Resume Next
                config.Add value, key
                On Error GoTo 0
            End If
        End If
    Loop
    Close #fileNum
    Set ParseConfigFile = config
End Function</code></pre>
<h3 id="read-log-file-with-timestamp-filter">Read Log File with Timestamp Filter</h3>
<pre><code class="language-vbnet">Function ReadLogsSince(logFile As String, sinceDate As Date) As Variant
    Dim fileNum As Integer
    Dim line As String
    Dim logs() As String
    Dim count As Long
    Dim lineDate As Date
    fileNum = FreeFile
    Open logFile For Input As #fileNum
    count = 0
    ReDim logs(0 To 100)
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        &#x27; Assuming timestamp is first 19 chars: &quot;2025-11-21 10:30:45&quot;
        If Len(line) &gt;= 19 Then
            On Error Resume Next
            lineDate = CDate(Left(line, 19))
            If Err.Number = 0 And lineDate &gt;= sinceDate Then
                logs(count) = line
                count = count + 1
                If count &gt; UBound(logs) Then
                    ReDim Preserve logs(0 To UBound(logs) + 100)
                End If
            End If
            On Error GoTo 0
        End If
    Loop
    Close #fileNum
    If count &gt; 0 Then
        ReDim Preserve logs(0 To count - 1)
        ReadLogsSince = logs
    Else
        ReadLogsSince = Array()
    End If
End Function</code></pre>
<h3 id="batch-process-multiple-files">Batch Process Multiple Files</h3>
<pre><code class="language-vbnet">Sub BatchProcessFiles(filePattern As String)
    Dim fileName As String
    Dim fileNum As Integer
    Dim line As String
    Dim processedCount As Long
    fileName = Dir(filePattern)
    Do While fileName &lt;&gt; &quot;&quot;
        fileNum = FreeFile
        Open fileName For Input As #fileNum
        Do Until EOF(fileNum)
            Line Input #fileNum, line
            ProcessLine line
        Loop
        Close #fileNum
        processedCount = processedCount + 1
        fileName = Dir
    Loop
    MsgBox processedCount &amp; &quot; files processed&quot;
End Sub</code></pre>
<h3 id="read-file-in-chunks">Read File in Chunks</h3>
<pre><code class="language-vbnet">Function ReadFileChunk(fileNum As Integer, chunkSize As Long) As Variant
    Dim lines() As String
    Dim line As String
    Dim count As Long
    ReDim lines(0 To chunkSize - 1)
    count = 0
    Do Until EOF(fileNum) Or count &gt;= chunkSize
        Line Input #fileNum, line
        lines(count) = line
        count = count + 1
    Loop
    If count &gt; 0 Then
        ReDim Preserve lines(0 To count - 1)
        ReadFileChunk = lines
    Else
        ReadFileChunk = Array()
    End If
End Function
&#x27; Usage with pagination
Sub ProcessLargeFile(filePath As String)
    Dim fileNum As Integer
    Dim chunk As Variant
    Dim pageNum As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    pageNum = 1
    Do Until EOF(fileNum)
        chunk = ReadFileChunk(fileNum, 1000)
        ProcessChunk chunk, pageNum
        pageNum = pageNum + 1
    Loop
    Close #fileNum
End Sub</code></pre>
<h3 id="database-import-from-text-file">Database Import from Text File</h3>
<pre><code class="language-vbnet">Sub ImportDataFromFile(filePath As String, tableName As String)
    Dim fileNum As Integer
    Dim line As String
    Dim fields() As String
    Dim sql As String
    Dim recordCount As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    &#x27; Skip header
    If Not EOF(fileNum) Then
        Line Input #fileNum, line
    End If
    recordCount = 0
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        fields = Split(line, vbTab)
        sql = &quot;INSERT INTO &quot; &amp; tableName &amp; &quot; VALUES (&#x27;&quot; &amp; _
              Join(fields, &quot;&#x27;,&#x27;&quot;) &amp; &quot;&#x27;)&quot;
        &#x27; Execute SQL (pseudo-code)
        ExecuteSQL sql
        recordCount = recordCount + 1
    Loop
    Close #fileNum
    MsgBox recordCount &amp; &quot; records imported&quot;
End Sub</code></pre>
<h3 id="create-file-index">Create File Index</h3>
<pre><code class="language-vbnet">Type FileIndex
    LineNumber As Long
    FilePosition As Long
    Content As String
End Type
Function BuildFileIndex(filePath As String) As Variant
    Dim fileNum As Integer
    Dim index() As FileIndex
    Dim line As String
    Dim count As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    count = 0
    ReDim index(0 To 100)
    Do Until EOF(fileNum)
        index(count).LineNumber = count + 1
        index(count).FilePosition = Seek(fileNum)
        Line Input #fileNum, line
        index(count).Content = Left(line, 100)  &#x27; Store first 100 chars
        count = count + 1
        If count &gt; UBound(index) Then
            ReDim Preserve index(0 To UBound(index) + 100)
        End If
    Loop
    Close #fileNum
    If count &gt; 0 Then
        ReDim Preserve index(0 To count - 1)
        BuildFileIndex = index
    Else
        BuildFileIndex = Array()
    End If
End Function</code></pre>
<h2 id="error-handling">Error Handling</h2>
<pre><code class="language-vbnet">Function SafeReadFile(filePath As String) As Variant
    On Error GoTo ErrorHandler
    Dim fileNum As Integer
    Dim lines() As String
    Dim line As String
    Dim count As Long
    fileNum = FreeFile
    Open filePath For Input As #fileNum
    count = 0
    ReDim lines(0 To 100)
    Do Until EOF(fileNum)
        Line Input #fileNum, line
        lines(count) = line
        count = count + 1
        If count &gt; UBound(lines) Then
            ReDim Preserve lines(0 To UBound(lines) + 100)
        End If
    Loop
    Close #fileNum
    If count &gt; 0 Then
        ReDim Preserve lines(0 To count - 1)
        SafeReadFile = lines
    Else
        SafeReadFile = Array()
    End If
    Exit Function
ErrorHandler:
    If fileNum &gt; 0 Then Close #fileNum
    SafeReadFile = Null
End Function</code></pre>
<h3 id="common-errors">Common Errors</h3>
<ul>
<li><strong>Error 52</strong> (Bad file name or number): File number is invalid or file is closed</li>
<li><strong>Error 62</strong> (Input past end of file): Attempted to read beyond EOF without checking</li>
<li><strong>Error 54</strong> (Bad file mode): File not opened for Input or Random access</li>
</ul>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li><code>EOF</code> is very fast (single status check)</li>
<li>No performance penalty for frequent calls</li>
<li>Use <code>Do Until EOF</code> rather than counting lines beforehand</li>
<li>For large files, consider buffered reading</li>
<li>Random access files: EOF checks record position</li>
<li>Sequential files: EOF checks character position</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<h3 id="always-use-eof-to-control-file-reading">Always Use EOF to Control File Reading</h3>
<pre><code class="language-vbnet">&#x27; Good - Use EOF to detect end
Do Until EOF(fileNum)
    Line Input #fileNum, line
    ProcessLine line
Loop
&#x27; Bad - May cause &quot;Input past end of file&quot; error
Do While True
    Line Input #fileNum, line  &#x27; Error if EOF reached
    ProcessLine line
Loop</code></pre>
<h3 id="always-close-files">Always Close Files</h3>
<pre><code class="language-vbnet">&#x27; Good - Always close, even on error
On Error GoTo ErrorHandler
Open filePath For Input As #fileNum
Do Until EOF(fileNum)
    &#x27; Process
Loop
Close #fileNum
Exit Sub
ErrorHandler:
    If fileNum &gt; 0 Then Close #fileNum</code></pre>
<h3 id="check-eof-before-reading">Check EOF Before Reading</h3>
<pre><code class="language-vbnet">&#x27; Good - Check before reading
If Not EOF(fileNum) Then
    Line Input #fileNum, line
End If
&#x27; Or use in loop condition
Do Until EOF(fileNum)
    Line Input #fileNum, line
Loop</code></pre>
<h2 id="comparison-with-other-methods">Comparison with Other Methods</h2>
<h3 id="eof-vs-lof">EOF vs LOF</h3>
<pre><code class="language-vbnet">&#x27; EOF - Detects end of file for Input/Random
Do Until EOF(fileNum)
    Line Input #fileNum, line
Loop
&#x27; LOF - Gets file length (useful for Binary mode)
Open file For Binary As #fileNum
fileSize = LOF(fileNum)</code></pre>
<h3 id="eof-vs-seek">EOF vs Seek</h3>
<pre><code class="language-vbnet">&#x27; EOF - Boolean end-of-file check
isAtEnd = EOF(fileNum)
&#x27; Seek - Get/set current position
currentPos = Seek(fileNum)</code></pre>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Only works with Input and Random access modes</li>
<li>Not applicable to Binary mode (use LOF and Seek)</li>
<li>Not applicable to Output or Append modes</li>
<li>Does not indicate how much data remains</li>
<li>File must be open</li>
<li>Cannot detect EOF before opening file</li>
</ul>
<h2 id="related-functions">Related Functions</h2>
<ul>
<li><code>LOF</code>: Returns length of file in bytes</li>
<li><code>Seek</code>: Returns or sets current position in file</li>
<li><code>Open</code>: Opens file for reading/writing</li>
<li><code>Close</code>: Closes open file</li>
<li><code>Line Input</code>: Reads line from file</li>
<li><code>Input</code>: Reads data from file</li>
<li><code>Get</code>: Reads data from random/binary file</li>
<li><code>FreeFile</code>: Returns next available file number</li>
</ul>
        </article>
        
        <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
            <p>
                <a href="index.html">‚Üê Back to File</a> |
                <a href="../index.html">View all functions</a>
            </p>
        </div>

    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024-2026 VB6Parse Contributors. Licensed under the MIT License.</p>
        </div>
    </footer>
</body>
</html>
