<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="VB6Parse Library Reference - input - Interaction">
    <title>input - Interaction - VB6Parse Library Reference</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
    <link rel="stylesheet" href="../../../assets/css/docs-style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="../../../assets/js/theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vbnet.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header class="docs-header">
        <div class="container">
            <h1><a href="../../../index.html">VB6Parse</a> / <a href="../../../library/index.html">Library</a> / <a href="../../../library/functions/interaction/index.html">Interaction</a> / input</h1>
            <p class="tagline">VB6 Library Reference</p>
        </div>
    </header>

    <nav class="docs-nav">
        <div class="container">
            <a href="../../../index.html">Home</a>
            <a href="../../../library/index.html">Library Reference</a>
            <a href="../../../documentation.html">Documentation</a>
            <a href="https://docs.rs/vb6parse" target="_blank">API Docs</a>
            <a href="https://github.com/scriptandcompile/vb6parse" target="_blank">GitHub</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </div>
    </nav>

    <main class="container">
        
        <article class="library-item">
            <h1 id="input-function"><code>Input</code> Function</h1>
<p>Returns a <code>String</code> containing characters from a file opened in <code>Input</code> or <code>Binary</code> mode.</p>
<h2 id="syntax">Syntax</h2>
<pre><code class="language-vbnet">Input(number, [#]filenumber)</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>number</code> (Required): <code>Long</code> expression specifying the number of characters to return</li>
<li><code>filenumber</code> (Required): <code>Integer</code> file number used in the <code>Open</code> statement (the # is optional)</li>
</ul>
<h2 id="return-value">Return Value</h2>
<p>Returns a <code>String</code> containing <code>number</code> characters read from the file. If fewer than <code>number</code>
characters remain in the file, returns all remaining characters.</p>
<h2 id="remarks">Remarks</h2>
<p>The <code>Input</code> function reads data from files:
- Used with files opened in <code>Input</code> or <code>Binary</code> mode
- Returns exactly the number of characters requested (or fewer if end of file reached)
- Does not skip or ignore any characters (unlike <code>Input #</code> statement)
- Reads all characters including commas, quotes, line feeds, carriage returns, etc.
- The file pointer advances by the number of characters read
- Use <code>EOF</code> function to check for end of file before reading
- For <code>Binary</code> mode files, reads raw bytes
- For <code>Input</code> mode files, reads text characters
- Cannot be used with files opened in <code>Output</code> or <code>Append</code> mode
- The # symbol before filenumber is optional but commonly used</p>
<h2 id="typical-uses">Typical Uses</h2>
<ol>
<li><strong>Binary File Reading</strong>: Read fixed-size chunks from binary files</li>
<li><strong>Text File Reading</strong>: Read specific number of characters from text files</li>
<li><strong>Fixed-Width Records</strong>: Read fixed-width record data</li>
<li><strong>File Parsing</strong>: Read file content for custom parsing</li>
<li><strong>Header Reading</strong>: Read file headers of known size</li>
<li><strong>Buffer Reading</strong>: Read file content into memory buffers</li>
</ol>
<h2 id="basic-usage-examples">Basic Usage Examples</h2>
<pre><code class="language-vbnet">&#x27; Example 1: Read 10 characters from a file
Dim fileNum As Integer
Dim content As String
fileNum = FreeFile
Open &quot;data.txt&quot; For Input As #fileNum
content = Input(10, #fileNum)
Close #fileNum
&#x27; Example 2: Read entire file
Dim fileNum As Integer
Dim fileContent As String
Dim fileSize As Long
fileNum = FreeFile
Open &quot;document.txt&quot; For Input As #fileNum
fileSize = LOF(fileNum)
fileContent = Input(fileSize, #fileNum)
Close #fileNum
&#x27; Example 3: Read file in chunks
Dim fileNum As Integer
Dim chunk As String
fileNum = FreeFile
Open &quot;data.bin&quot; For Binary As #fileNum
Do While Not EOF(fileNum)
    chunk = Input(1024, #fileNum)
    ProcessChunk chunk
Loop
Close #fileNum
&#x27; Example 4: Read fixed-width record
Dim fileNum As Integer
Dim record As String
fileNum = FreeFile
Open &quot;records.dat&quot; For Binary As #fileNum
record = Input(80, #fileNum)  &#x27; Read 80-character record
Close #fileNum</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<pre><code class="language-vbnet">&#x27; Pattern 1: Read entire file into string
Function ReadFileToString(fileName As String) As String
    Dim fileNum As Integer
    Dim fileSize As Long
    fileNum = FreeFile
    Open fileName For Input As #fileNum
    fileSize = LOF(fileNum)
    If fileSize &gt; 0 Then
        ReadFileToString = Input(fileSize, #fileNum)
    Else
        ReadFileToString = &quot;&quot;
    End If
    Close #fileNum
End Function
&#x27; Pattern 2: Read file in fixed-size chunks
Sub ReadFileInChunks(fileName As String, chunkSize As Long)
    Dim fileNum As Integer
    Dim chunk As String
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    Do While Not EOF(fileNum)
        chunk = Input(chunkSize, #fileNum)
        Debug.Print &quot;Read &quot; &amp; Len(chunk) &amp; &quot; bytes&quot;
    Loop
    Close #fileNum
End Sub
&#x27; Pattern 3: Read file header
Function ReadFileHeader(fileName As String, headerSize As Long) As String
    Dim fileNum As Integer
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    If LOF(fileNum) &gt;= headerSize Then
        ReadFileHeader = Input(headerSize, #fileNum)
    Else
        ReadFileHeader = &quot;&quot;
    End If
    Close #fileNum
End Function
&#x27; Pattern 4: Read until delimiter found
Function ReadUntilDelimiter(fileNum As Integer, delimiter As String) As String
    Dim result As String
    Dim char As String
    result = &quot;&quot;
    Do While Not EOF(fileNum)
        char = Input(1, #fileNum)
        If char = delimiter Then
            Exit Do
        End If
        result = result &amp; char
    Loop
    ReadUntilDelimiter = result
End Function
&#x27; Pattern 5: Peek at file content without closing
Function PeekFileContent(fileNum As Integer, bytes As Long) As String
    Dim currentPos As Long
    Dim content As String
    currentPos = Seek(fileNum)
    content = Input(bytes, #fileNum)
    Seek fileNum, currentPos  &#x27; Restore position
    PeekFileContent = content
End Function
&#x27; Pattern 6: Read line character by character
Function ReadCustomLine(fileNum As Integer) As String
    Dim result As String
    Dim char As String
    result = &quot;&quot;
    Do While Not EOF(fileNum)
        char = Input(1, #fileNum)
        If char = vbCr Or char = vbLf Then
            &#x27; Skip additional line feed if CRLF
            If char = vbCr And Not EOF(fileNum) Then
                If Input(1, #fileNum) &lt;&gt; vbLf Then
                    Seek fileNum, Seek(fileNum) - 1
                End If
            End If
            Exit Do
        End If
        result = result &amp; char
    Loop
    ReadCustomLine = result
End Function
&#x27; Pattern 7: Read binary structure
Function ReadBinaryStruct(fileNum As Integer, structSize As Long) As Byte()
    Dim data As String
    Dim bytes() As Byte
    Dim i As Long
    data = Input(structSize, #fileNum)
    ReDim bytes(0 To Len(data) - 1)
    For i = 0 To Len(data) - 1
        bytes(i) = Asc(Mid$(data, i + 1, 1))
    Next i
    ReadBinaryStruct = bytes
End Function
&#x27; Pattern 8: Safe read with EOF check
Function SafeRead(fileNum As Integer, numChars As Long) As String
    Dim available As Long
    Dim toRead As Long
    available = LOF(fileNum) - Seek(fileNum) + 1
    toRead = IIf(numChars &lt; available, numChars, available)
    If toRead &gt; 0 Then
        SafeRead = Input(toRead, #fileNum)
    Else
        SafeRead = &quot;&quot;
    End If
End Function
&#x27; Pattern 9: Read with progress tracking
Function ReadFileWithProgress(fileName As String) As String
    Dim fileNum As Integer
    Dim fileSize As Long
    Dim bytesRead As Long
    Dim chunk As String
    Dim result As String
    Const CHUNK_SIZE As Long = 4096
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    fileSize = LOF(fileNum)
    result = &quot;&quot;
    bytesRead = 0
    Do While Not EOF(fileNum)
        chunk = Input(CHUNK_SIZE, #fileNum)
        result = result &amp; chunk
        bytesRead = bytesRead + Len(chunk)
        &#x27; Update progress (0 to 100)
        DoEvents
        Debug.Print &quot;Progress: &quot; &amp; (bytesRead * 100 / fileSize) &amp; &quot;%&quot;
    Loop
    Close #fileNum
    ReadFileWithProgress = result
End Function
&#x27; Pattern 10: Read specific byte range
Function ReadByteRange(fileName As String, startPos As Long, numBytes As Long) As String
    Dim fileNum As Integer
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    Seek fileNum, startPos
    ReadByteRange = Input(numBytes, #fileNum)
    Close #fileNum
End Function</code></pre>
<h2 id="advanced-usage-examples">Advanced Usage Examples</h2>
<pre><code class="language-vbnet">&#x27; Example 1: Binary file reader class
Public Class BinaryFileReader
    Private m_fileNum As Integer
    Private m_fileName As String
    Private m_isOpen As Boolean
    Public Sub OpenFile(fileName As String)
        If m_isOpen Then CloseFile
        m_fileName = fileName
        m_fileNum = FreeFile
        Open m_fileName For Binary As #m_fileNum
        m_isOpen = True
    End Sub
    Public Function ReadBytes(numBytes As Long) As String
        If Not m_isOpen Then
            Err.Raise 5, , &quot;File not open&quot;
        End If
        If EOF(m_fileNum) Then
            ReadBytes = &quot;&quot;
        Else
            ReadBytes = Input(numBytes, #m_fileNum)
        End If
    End Function
    Public Function ReadAll() As String
        If Not m_isOpen Then
            Err.Raise 5, , &quot;File not open&quot;
        End If
        Dim fileSize As Long
        fileSize = LOF(m_fileNum) - Seek(m_fileNum) + 1
        If fileSize &gt; 0 Then
            ReadAll = Input(fileSize, #m_fileNum)
        Else
            ReadAll = &quot;&quot;
        End If
    End Function
    Public Sub CloseFile()
        If m_isOpen Then
            Close #m_fileNum
            m_isOpen = False
        End If
    End Sub
    Private Sub Class_Terminate()
        CloseFile
    End Sub
End Class
&#x27; Example 2: Custom file parser
Function ParseFixedWidthFile(fileName As String) As Collection
    Dim fileNum As Integer
    Dim records As New Collection
    Dim recordData As String
    Const RECORD_SIZE As Long = 100
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    Do While Not EOF(fileNum)
        recordData = Input(RECORD_SIZE, #fileNum)
        If Len(recordData) = RECORD_SIZE Then
            records.Add ParseRecord(recordData)
        End If
    Loop
    Close #fileNum
    Set ParseFixedWidthFile = records
End Function
&#x27; Example 3: File comparison utility
Function CompareFiles(file1 As String, file2 As String) As Boolean
    Dim fileNum1 As Integer, fileNum2 As Integer
    Dim chunk1 As String, chunk2 As String
    Const CHUNK_SIZE As Long = 8192
    fileNum1 = FreeFile
    Open file1 For Binary As #fileNum1
    fileNum2 = FreeFile
    Open file2 For Binary As #fileNum2
    &#x27; Check file sizes
    If LOF(fileNum1) &lt;&gt; LOF(fileNum2) Then
        Close #fileNum1
        Close #fileNum2
        CompareFiles = False
        Exit Function
    End If
    &#x27; Compare content
    Do While Not EOF(fileNum1)
        chunk1 = Input(CHUNK_SIZE, #fileNum1)
        chunk2 = Input(CHUNK_SIZE, #fileNum2)
        If chunk1 &lt;&gt; chunk2 Then
            Close #fileNum1
            Close #fileNum2
            CompareFiles = False
            Exit Function
        End If
    Loop
    Close #fileNum1
    Close #fileNum2
    CompareFiles = True
End Function
&#x27; Example 4: Large file reader with buffering
Function ReadLargeFile(fileName As String, Optional bufferSize As Long = 32768) As String
    Dim fileNum As Integer
    Dim result As String
    Dim chunk As String
    Dim chunks As Collection
    Dim i As Long
    Set chunks = New Collection
    fileNum = FreeFile
    Open fileName For Binary As #fileNum
    &#x27; Read in chunks
    Do While Not EOF(fileNum)
        chunk = Input(bufferSize, #fileNum)
        chunks.Add chunk
    Loop
    Close #fileNum
    &#x27; Concatenate chunks
    result = &quot;&quot;
    For i = 1 To chunks.Count
        result = result &amp; chunks(i)
    Next i
    ReadLargeFile = result
End Function</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>The <code>Input</code> function can raise several errors:
- <strong>Bad file mode (Error 54)</strong>: If file is not opened in <code>Input</code> or <code>Binary</code> mode
- <strong>Bad file number (Error 52)</strong>: If filenumber is invalid or file is not open
- <strong>Input past end of file (Error 62)</strong>: Only if reading past <code>EOF</code> (rare, usually returns partial data)
- <strong>Type Mismatch (Error 13)</strong>: If number parameter is not numeric</p>
<pre><code class="language-vbnet">On Error GoTo ErrorHandler
Dim fileNum As Integer
Dim content As String
fileNum = FreeFile
Open &quot;data.txt&quot; For Input As #fileNum
content = Input(LOF(fileNum), #fileNum)
Close #fileNum
Exit Sub
ErrorHandler:
    If fileNum &gt; 0 Then Close #fileNum
    MsgBox &quot;Error reading file: &quot; &amp; Err.Description, vbCritical</code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li><strong>Buffer Size</strong>: Reading in larger chunks (4KB-32KB) is more efficient than single bytes</li>
<li><strong><code>String</code> Concatenation</strong>: For large files, use collection of chunks then join</li>
<li><strong>Memory Usage</strong>: Reading entire large files into memory can cause issues</li>
<li><strong>File Mode</strong>: Binary mode is faster than Input mode for raw data</li>
<li><strong><code>LOF</code> Function</strong>: Call <code>LOF</code> once and store result rather than calling repeatedly</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Check <code>EOF</code></strong>: Always check <code>EOF</code> before reading to avoid errors</li>
<li><strong>Close Files</strong>: Always close files in error handlers to prevent leaks</li>
<li><strong>Use <code>LOF</code></strong>: Use <code>LOF</code> to determine file size before reading entire file</li>
<li><strong>Chunk Reading</strong>: Read large files in chunks to manage memory</li>
<li><strong>Binary Mode</strong>: Use <code>Binary</code> mode for most file reading operations</li>
<li><strong>Error Handling</strong>: Wrap file operations in proper error handling</li>
<li><strong>Free Resources</strong>: <code>Close</code> files as soon as done reading</li>
</ol>
<h2 id="comparison-with-other-functions">Comparison with Other Functions</h2>
<table>
<thead>
<tr>
<th>Function/Statement</th>
<th>Purpose</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Input</code></td>
<td>Read exact number of characters</td>
<td><code>s = Input(100, #1)</code></td>
</tr>
<tr>
<td><code>Input #</code></td>
<td>Read comma-delimited data</td>
<td><code>Input #1, var1, var2</code></td>
</tr>
<tr>
<td><code>Line Input #</code></td>
<td>Read entire line</td>
<td><code>Line Input #1, s</code></td>
</tr>
<tr>
<td><code>Get</code></td>
<td>Read binary data into variables</td>
<td><code>Get #1, , myVar</code></td>
</tr>
<tr>
<td><code>LOF</code></td>
<td>Get file length</td>
<td><code>size = LOF(1)</code></td>
</tr>
<tr>
<td><code>EOF</code></td>
<td>Check end of file</td>
<td><code>If EOF(1) Then...</code></td>
</tr>
</tbody>
</table>
<h2 id="platform-and-version-notes">Platform and Version Notes</h2>
<ul>
<li>Available in all VB6 versions</li>
<li>Consistent behavior across Windows platforms</li>
<li>Maximum string length limitations apply (approximately 2GB in VB6)</li>
<li>File must be opened before using Input function</li>
<li>The # symbol before filenumber is optional</li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Cannot be used with files opened in <code>Output</code> or <code>Append</code> mode</li>
<li>Reading very large files into single string may cause memory issues</li>
<li>No built-in Unicode support (use <code>ADODB.Stream</code> for Unicode)</li>
<li><code>String</code> concatenation for large files can be slow</li>
<li>Limited to approximately 2GB string size on 32-bit systems</li>
<li>No built-in compression or encoding support</li>
</ul>
<h2 id="related-functions">Related Functions</h2>
<ul>
<li><code>Input #</code>: Statement for reading delimited data from files</li>
<li><code>Line Input #</code>: Statement for reading complete lines</li>
<li><code>Get</code>: Statement for reading binary data into variables</li>
<li><code>LOF</code>: Returns the size of an open file in bytes</li>
<li><code>EOF</code>: Returns <code>True</code> if at end of file</li>
<li><code>Seek</code>: Function/statement for getting/setting file position</li>
<li><code>Open</code>: Statement for opening files</li>
<li><code>Close</code>: Statement for closing files</li>
</ul>
        </article>
        
        <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
            <p>
                <a href="index.html">‚Üê Back to Interaction</a> |
                <a href="../index.html">View all functions</a>
            </p>
        </div>

    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024-2026 VB6Parse Contributors. Licensed under the MIT License.</p>
        </div>
    </footer>
</body>
</html>
